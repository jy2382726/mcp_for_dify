# ALIGNMENT_text_splitter

## 1. 原始需求
用户希望修改 `TextSplitterService` 中 PDF 文本的处理逻辑 (`mode='pdf'`)。
目标是实现基于文档结构的层级分块，并保护特定内容不被截断。

### 核心要求
1.  **父块 (Parent Block) 切分策略**:
    *   优先按章节切分：一级标题 (`#`) -> 二级标题 (`##`) -> ...
    *   如果某层级切分后的块仍超过 `parent_block_size`，则尝试下一层级。
    *   如果已无标题可切分但仍超长，则按段落/句子切分（兜底）。
    *   尽可能保证父块是一个完整的章节或语义单元。
2.  **子块 (Child Block) 切分策略**:
    *   在父块内部切分。
    *   **完整性约束**:
        *   图片解析内容 (`【图片解析内容...】`) 必须保持完整，不能被切断。
        *   Markdown 表格必须保持完整，不能被切断。

## 2. 现有代码分析 (`text_splitter_service.py`)
*   当前逻辑主要基于 `BOUNDARY_PDF` (正则) 进行分句/分行，然后按长度累积 (`_join_units_with_limit`)。
*   缺乏对 Markdown 标题结构的感知。
*   缺乏对特定格式（图片、表格）的原子性保护（虽然有 `_protect_special_tokens` 处理 URL 和反引号代码，但未涵盖图片和表格）。

## 3. 技术方案设计

### 3.1 预处理与保护
*   **扩展保护机制**:
    *   识别 `【图片解析内容...】` 正则: `r"【图片解析内容[^】]*】"`
    *   识别 Markdown 表格: 连续的以 `|` 开头的行。
    *   将这些内容替换为特殊 Token (e.g., `<<BLOCK_IMG_0>>`, `<<BLOCK_TABLE_0>>`)，确保后续字符串操作将其视为一个原子字符。

### 3.2 递归层级切分 (Parent Blocks)
*   定义切分层级列表: `["# ", "## ", "### ", "#### ", "##### ", "###### "]`。
*   **算法**:
    1.  输入文本 `text`，当前层级 `level_idx`。
    2.  如果 `len(text) <= parent_block_size`，直接返回 `[text]`。
    3.  如果 `level_idx` 超出范围，回退到按段落 (`\n\n`) 或句子切分。
    4.  尝试按当前层级标题切分：
        *   使用正则 `(?m)^(#+ )` (注意需要匹配行首)。
        *   切分后需将标题保留在对应的块中。
    5.  对切分后的每个子块：
        *   如果块大小合适，保留。
        *   如果块过大，递归调用下一层级 (`level_idx + 1`)。

### 3.3 子块切分 (Child Blocks)
*   对每个父块，进行二次切分。
*   由于图片和表格已被 Token 化，它们不会被切断。
*   使用类似 `RecursiveCharacterTextSplitter` 的逻辑，按 `\n\n`, `\n`, `。`, ` ` 等分隔符尝试切分，直到满足 `sub_block_size`。

### 3.4 恢复
*   将 Token 还原为原始内容。

## 4. 伪代码示例
(将在对话中展示)

## 5. 验收标准
1.  对于包含层级标题的文档，父块应尽量对应章节。
2.  超长章节应被合理切分。
3.  `【图片解析内容...】` 始终完整。
4.  Markdown 表格始终完整。
